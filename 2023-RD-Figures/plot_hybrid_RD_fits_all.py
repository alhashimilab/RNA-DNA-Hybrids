import matplotlib.gridspec as gridspec
import math
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import sys
import os
import matplotlib
from mpl_toolkits.axes_grid1.inset_locator import inset_axes

matplotlib.rcParams['axes.linewidth'] = 4.0
#matplotlib.rcParams['font-family']='Sans-serif'
fs = 24
fs2 = 8

r1p_simulation = '''
##################################################################################
# Run the BMNS simulation routine:
# > python BMNS.py -sim [BM Simulation Input File] (Optional Output directory)
##################################################################################
# "Params" block is where simulation parameters are defined.
#   Parameters can be defined manually, or read-in from a BM-fit CSV file
# If you read in fit CSV you can then manually define some parameters,
#   this will overwrite the parameters read in from CSV.
#---------------------------------------------------------------------------------
# - 'Read' reads in a BM fit csv file from local directory
#     only uses kexAB, kexAC, kexBC for exchange rates, not indv rate constants
#   This can replace or complement the individually specified values
# - 'lf' is larmor frequency of spin (e.g. 150.8MHz for 13C, etc)
# - 'AlignMag' is auto/gs/avg for automatic, ground-state, or average alignment
# - 'pB/pC' are populations of state B/C
# - 'kexAB/AC/BC' are exchange rates between the 3 states A,B, and C
# - 'R1/R2' are the intrinsic relax rates of states A/B/C
# Any of the above parameters can be commented out provided they are read-in
#  from a CSV file instead.
##################################################################################
+
Params
#Read pars.csv
lf %f
AlignMag Auto
pB %f 
pC %f
dwB %f
dwC %f
kexAB %f
kexAC %f
kexBC %f
R1 %f
R2 %f
R1b %f
R2b %f
R1c %f
R2c %f

##################################################################################
# "SLOFF" block defines spinlock powers and offsets to simulate with BM.
# Additionally, real data can be read in to be overlaid with simulated data.
# Additionally, simulated data can be error corrupted at the level of the
#     R1rho value to a certain percentage. Monte-Carlo iterations can be
#   defined for this error corruption.
#---------------------------------------------------------------------------------
# - 'Read' defines a .csv file that can be read in
#       that contains Offset(Hz), SLP(Hz) in columns
#       and these will be simulated. If commented out
#     then they will not be read in.
# - 'Data' defines a .csv file that contains real data.
#      Can directly read in data file generated by
#     the BM fitting routine.
#   Order is:
#    Col1: Corrected Offset(Hz)
#    Col2: SLP (Hz)
#    Col3: R1rho
#    Col4: R1rho error (must exist, even if all zeros)
#    Col5: R2eff
#    Col6: R2eff error (must exist, even if all zeros)
#   If not defined, then they will not be read in.
# - 'Error' noise corruption for simulated R1rho values.
#   e.g. 0.02 would error corrupt R1rho by 2%%
#   Generates error from MC error corruption, selecting
#   sigma from gaussian distribution around corrupted
#   R1rho value
# - 'MCNum' defines number of MC iterations for noise corruption.
# - 'on' Defines on-resonance R1rho values to be simulated
#  Add as many of these as you wish
#     Col1: 'on'
#   Col2: Lower SLP (Hz)
#   Col3: Upper SLP (Hz)
#   Col4: Number of onres SLPs to simulate between low/high
# - 'off' defines off-resonance R1rho values to be simulated
#   at a given SLP over a range of offsets.
#    Add as many 'off' rows as you need to generate more
#   more off-resonance points or spinlock powers
#     Col1: 'off'
#   Col2: SLP (Hz)
#   Col3: Lower Offset (Hz)
#   Col4: Upper Offset (Hz)
#   Col5: Number of offres SLPs to simulate between low/high
##################################################################################
+
SLOFF
#Read sloffs.csv
#Data data.csv
Error 0.0
MCNum 500
off %f %f %f 200
off %f %f %f 200
off %f %f %f 200
off %f %f %f 200
off %f %f %f 200

##################################################################################
# "Decay" block defines how each R1rho value is simulated by simulating decaying
#   magnetization as a function of time given parameters describing the chemical
#   exchange between 2/3 species.
# Decay is assumed to be monoexponential, and simulated R1rho values are given
#   by the monoexponential fit of decaying magnetization.
# Note: This assumption can be violated under some conditions, where decay
#       can be bi-exponential or other (not take in to account).
# Additionally, intensity values can be noise corrupted to give a noise
#   corrupted R1rho value originating from N-number of corrupted monoexponential
#   fits. This is approximating how we derive R1rho experimentally and its error.
#---------------------------------------------------------------------------------
# - 'vdlist' a number of delay points to simulate decaying magnetization over.
#     Col2: Lowest delay in seconds (usually 0)
#   Col3: Longest delay in seconds (>0.1 is good, but can use anything)
#   Col4: Number of delays between low and high
# - 'Read' defines a delay list to read in. This is any text file where each row
#   is a delay given in seconds (e.g. vdlist).
#   If commented out, it will not be read in. If given, it will be comined with
#   delay values simulated with the 'vdlist' command below.
# - 'PlotDec' can be 'yes' or 'no'. If 'yes', then it will plot the
#   simulated decay for each SLP/offset combination along with
#   the best-fit line for the R1rho value at that point.
#   WARNING: This can take a long time if you are simulating lots of data
# - 'Error' defines noise corruption value for simulated magnetization
#   at each time point. E.g. 0.02 would be 2%% noise corruption.
#   Error here translates to error in R1rho by simulating N=MCNum of
#     noise-corrupted monoexponential decays and fitting them and
#     calculating the error in R1rho from the distribution of fitted
#     R1rhos (error = sigma of gaussian distribution of fitted R1rhos)
# - 'MCNum' defines how many noise-corrupted decays to simulate and fit.
#     WARNING: This can take a long time if you are simulating a lot of data.
##################################################################################
+
Decay
vdlist 0.0 0.25 51
#Read delays
PlotDec no
Error 0.0
MCNum 500

##################################################################################
# "Plot" block lets you specify how to plot your simulated/real data.
#---------------------------------------------------------------------------------
# - 'Plot' can be 'line', 'symbol', or 'both'.
#   'Line' will plot a simulated line of R1rho values
#   'Symbol' will plot simulated R1rhos as symbol types defined below
#   'Both' with plot symbols over simulated lines
# - 'Line' defines the style of the line plot.
#   Col2: Type of line, see: 
#   http://matplotlib.org/examples/lines_bars_and_markers/line_styles_reference.html
#      -   -.  --  or  : 
#     Col3: Line-width, in pixels
# - 'Symbol' defines the style of the symbol plot.
#   Col2: Type of symbol, see: http://matplotlib.org/api/markers_api.html
#     Too many to list, but default is a filled circle: o
#   Col3: Size of symbol (pixels)
# - 'Overlay' defines how you plot data overlaid on simulation
# - 'OType' type of data to overlay, real or overlay.
# - 'OLine' line type for overlay
# - 'OSymbol' symbol type for overlay
# - 'Size' defines the plot width and height in inches
# - '(R1p/R2eff/On)_x/y' define the lower and upper limits of the respective axes
#   Comment out to let them be automatically defined.
#   Alternatively, set one or both values to 'None' to let the program
#   automatically define the limit of the lower/upper bounds, individually
#   e.g. 'R1p_x None 1000' would let lower x-axis limits be automatically
#   defined, but the upper limit would be set to 1000
# - 'Axis_FS' sets the axes numbers font sizes, X and Y axes, respectively
# - 'LabelFS' sets the X and Y axes labels font sizes
##################################################################################
+
Plot line
Line - 2
Symbol o 13
Overlay line
OType sim
OLine -- 2
OSymbol . 13
Size 10 8
#R1p_x None 1000
#R1p_y 0 100
#R2eff_x -1000 1000
#R2eff_y 0 100
On_x 0 None
#On_y 0 50
Axis_FS 32 32
Label_FS 32 32
Labels on
'''

cest_simulation = '''
##################################################################################
# Run the BMNS simulation routine:
# > python BMNS.py -sim [BM Simulation Input File] (Optional Output directory)
##################################################################################
# "Params" block is where simulation parameters are defined.
#   Parameters can be defined manually, or read-in from a BM-fit CSV file
# If you read in fit CSV you can then manually define some parameters,
#   this will overwrite the parameters read in from CSV.
#---------------------------------------------------------------------------------
# - 'Read' reads in a BM fit csv file from local directory
#     only uses kexAB, kexAC, kexBC for exchange rates, not indv rate constants
#   This can replace or complement the individually specified values
# - 'lf' is larmor frequency of spin (e.g. 150.8MHz for 13C, etc)
# - 'AlignMag' is auto/gs/avg for automatic, ground-state, or average alignment
# - 'pB/pC' are populations of state B/C
# - 'kexAB/AC/BC' are exchange rates between the 3 states A,B, and C
# - 'R1/R2' are the intrinsic relax rates of states A/B/C
# Any of the above parameters can be commented out provided they are read-in
#  from a CSV file instead.
##################################################################################
+
lf %f
pb %f
pc 0.0
dwb %f
dwc 0.0
kexAB %f
kexAC 0.0
kexBC 0.0
R1a %f
R2a %f
R1b %f
R2b %f
R1c %f
R2c %f
resn 1.0
T %f
mode %s
error_point 0.000
error_baseinten 0.00
inhomo %f
equil N
ls N
J %f

##################################################################################
# "SLOFF" block defines spinlock powers and offsets to simulate with BM.
# Additionally, real data can be read in to be overlaid with simulated data.
# Additionally, simulated data can be error corrupted at the level of the
#     R1rho value to a certain percentage. Monte-Carlo iterations can be
#   defined for this error corruption.
#---------------------------------------------------------------------------------
# - 'Read' defines a .csv file that can be read in
#       that contains Offset(Hz), SLP(Hz) in columns
#       and these will be simulated. If commented out
#     then they will not be read in.
# - 'Data' defines a .csv file that contains real data.
#      Can directly read in data file generated by
#     the BM fitting routine.
#   Order is:
#    Col1: Corrected Offset(Hz)
#    Col2: SLP (Hz)
#    Col3: R1rho
#    Col4: R1rho error (must exist, even if all zeros)
#    Col5: R2eff
#    Col6: R2eff error (must exist, even if all zeros)
#   If not defined, then they will not be read in.
# - 'Error' noise corruption for simulated R1rho values.
#   e.g. 0.02 would error corrupt R1rho by 2%%
#   Generates error from MC error corruption, selecting
#   sigma from gaussian distribution around corrupted
#   R1rho value
# - 'MCNum' defines number of MC iterations for noise corruption.
# - 'on' Defines on-resonance R1rho values to be simulated
#  Add as many of these as you wish
#     Col1: 'on'
#   Col2: Lower SLP (Hz)
#   Col3: Upper SLP (Hz)
#   Col4: Number of onres SLPs to simulate between low/high
# - 'off' defines off-resonance R1rho values to be simulated
#   at a given SLP over a range of offsets.
#    Add as many 'off' rows as you need to generate more
#   more off-resonance points or spinlock powers
#     Col1: 'off'
#   Col2: SLP (Hz)
#   Col3: Lower Offset (Hz)
#   Col4: Upper Offset (Hz)
#   Col5: Number of offres SLPs to simulate between low/high
##################################################################################
+
off %f %f %f 250
off %f %f %f 250
off %f %f %f 250
off %f %f %f 250

#off 35.0 -4000.0 4000.0 300
#off 75.0 -4000.0 4000.0 300
#off 400.0 -4000.0 4000.0 300
#off 500.0 -4000.0 4000.0 300
#off 35.0 -1000.0 1000.0 200
#off 17.68 -1412.2 567.8 670
#off 27.90 -1422.2 577.8 510
#off 48.21 -1422.2 577.8 410


##################################################################################
# "Decay" block defines how each R1rho value is simulated by simulating decaying
#   magnetization as a function of time given parameters describing the chemical
#   exchange between 2/3 species.
# Decay is assumed to be monoexponential, and simulated R1rho values are given
#   by the monoexponential fit of decaying magnetization.
# Note: This assumption can be violated under some conditions, where decay
#       can be bi-exponential or other (not take in to account).
# Additionally, intensity values can be noise corrupted to give a noise
#   corrupted R1rho value originating from N-number of corrupted monoexponential
#   fits. This is approximating how we derive R1rho experimentally and its error.
#---------------------------------------------------------------------------------
# - 'vdlist' a number of delay points to simulate decaying magnetization over.
#     Col2: Lowest delay in seconds (usually 0)
#   Col3: Longest delay in seconds (>0.1 is good, but can use anything)
#   Col4: Number of delays between low and high
# - 'Read' defines a delay list to read in. This is any text file where each row
#   is a delay given in seconds (e.g. vdlist).
#   If commented out, it will not be read in. If given, it will be comined with
#   delay values simulated with the 'vdlist' command below.
# - 'PlotDec' can be 'yes' or 'no'. If 'yes', then it will plot the
#   simulated decay for each SLP/offset combination along with
#   the best-fit line for the R1rho value at that point.
#   WARNING: This can take a long time if you are simulating lots of data
# - 'Error' defines noise corruption value for simulated magnetization
#   at each time point. E.g. 0.02 would be 2%% noise corruption.
#   Error here translates to error in R1rho by simulating N=MCNum of
#     noise-corrupted monoexponential decays and fitting them and
#     calculating the error in R1rho from the distribution of fitted
#     R1rhos (error = sigma of gaussian distribution of fitted R1rhos)
# - 'MCNum' defines how many noise-corrupted decays to simulate and fit.
#     WARNING: This can take a long time if you are simulating a lot of data.
##################################################################################
+
Decay
vdlist 0.0 0.25 51
#Read delays
PlotDec no
Error 0.0
MCNum 500

##################################################################################
# "Plot" block lets you specify how to plot your simulated/real data.
#---------------------------------------------------------------------------------
# - 'Plot' can be 'line', 'symbol', or 'both'.
#   'Line' will plot a simulated line of R1rho values
#   'Symbol' will plot simulated R1rhos as symbol types defined below
#   'Both' with plot symbols over simulated lines
# - 'Line' defines the style of the line plot.
#   Col2: Type of line, see: 
#   http://matplotlib.org/examples/lines_bars_and_markers/line_styles_reference.html
#      -   -.  --  or  : 
#     Col3: Line-width, in pixels
# - 'Symbol' defines the style of the symbol plot.
#   Col2: Type of symbol, see: http://matplotlib.org/api/markers_api.html
#     Too many to list, but default is a filled circle: o
#   Col3: Size of symbol (pixels)
# - 'Overlay' defines how you plot data overlaid on simulation
# - 'OType' type of data to overlay, real or overlay.
# - 'OLine' line type for overlay
# - 'OSymbol' symbol type for overlay
# - 'Size' defines the plot width and height in inches
# - '(R1p/R2eff/On)_x/y' define the lower and upper limits of the respective axes
#   Comment out to let them be automatically defined.
#   Alternatively, set one or both values to 'None' to let the program
#   automatically define the limit of the lower/upper bounds, individually
#   e.g. 'R1p_x None 1000' would let lower x-axis limits be automatically
#   defined, but the upper limit would be set to 1000
# - 'Axis_FS' sets the axes numbers font sizes, X and Y axes, respectively
# - 'LabelFS' sets the X and Y axes labels font sizes
##################################################################################
+
Plot line
Line - 2
Symbol o 13
Overlay line
OType sim
OLine -- 2
OSymbol . 13
Size 10 8
#R1p_x None 1000
#R1p_y 0 100
#R2eff_x -1000 1000
#R2eff_y 0 100
On_x 0 None
#On_y 0 50
Axis_FS 32 32
Label_FS 32 32
Labels on
'''


def plot_r1p(ax, bf, trendlines, xaxis_lims, lim, step, ylims, fmt_string):
    ''' plot data frame inside given axis object '''
    color_slps = ['b', 'g', 'orange', 'brown', 'purple', 'r', 'magenta', 'black', 'cyan']
    #color_slps = ['b', 'g', 'orange', 'brown', 'r', 'magenta', 'black', 'cyan']
    unique_slps = np.sort(np.unique(bf['SLP']))
    counter = 0
    for unique_slp in unique_slps:
        bf_subset = bf.loc[bf['SLP'] == unique_slp]
        ax.errorbar(bf_subset['Offset'], bf_subset['R2eff'], yerr=bf_subset['R2eff err'], fmt='o', color=color_slps[counter], elinewidth=4, markersize=5, label=str(int(unique_slp)),capsize=4, capthick=4, mec=color_slps[counter], mfc=color_slps[counter], mew=2, zorder=100)
        #ax.plot(bf_subset['Offset'], bf_subset[' Sim R2eff'], color='k', marker='o', linewidth=0.0) 

        if len(trendlines) != 0:
            trendlines_sim = trendlines.loc[trendlines['slp'] == unique_slp]
            ax.plot(trendlines_sim['offset'], trendlines_sim['r2eff'], color=color_slps[counter], linewidth=4, label='', zorder=0)
     
        ax.tick_params(axis='x', direction='out', width=4, length=8, top=False)
        ax.tick_params(axis='y', direction='out', width=4, length=8, right=False)
    
        ax.set_xlim(xaxis_lims)
        ax.set_xticks([int(ele) for ele in np.arange(-1.*lim, lim+1, step)])
        ax.set_xticklabels([fmt_string%(float(ele)/1000.) for ele in np.arange(-1.*lim, lim+1, step)], fontsize=fs)
         
        ax.set_ylim([ylims[0], ylims[1]])
        ax.set_yticks([int(ele) for ele in np.arange(ylims[0], ylims[1]+1, ylims[2])])
        ax.set_yticklabels([str(int(ele)) for ele in np.arange(ylims[0], ylims[1]+1, ylims[2])], fontsize=fs)

        counter = counter + 1


    counter = 0
    handles, labels = ax.get_legend_handles_labels()
    handles = [h[0] if type(h) is not mpl.lines.Line2D else h for h in handles]
    leg = ax.legend(handles, labels, title='$\omega_{1}/2\pi$' + ' ' + '$(Hz)$', fancybox=False, ncol=2, handlelength=0, frameon=False, columnspacing=0.0, markerscale=0.0, handletextpad=0.2, borderpad=0.0, handleheight=0.0, labelspacing=0.2, fontsize=fs)

    for text in leg.get_texts():
        text.set_color(color_slps[counter])
        counter = counter + 1
    for l in leg.get_lines():
        l.set_linestyle('None')
    leg.set_title('$\omega_{1}/2\pi$' + ' ' + '$(Hz)$', prop={'size':fs})

def get_simulation_r1p(slps, offsets, fitpars, sim_number):
    ''' run a simulation '''
    # Make the net number of slps = 5
    if len(slps) == 4:
        slps = list(slps)
        slps.append(slps[-1]+200.)
        slps = np.array(slps)
    # Write out simulation file
    f = open('BMNS_Simparams.txt', 'w')
    f.write(r1p_simulation%(fitpars['lf'].values[0], fitpars['pB'].values[0], fitpars['pC'].values[0], fitpars['dwB'].values[0], fitpars['dwC'].values[0], fitpars['kexAB'].values[0], fitpars['kexAC'].values[0], fitpars['kexBC'].values[0], fitpars['R1'].values[0], fitpars['R2'].values[0], fitpars['R1b'].values[0], fitpars['R2b'].values[0], fitpars['R1c'].values[0], fitpars['R2c'].values[0], slps[0], offsets[0], offsets[1], slps[1], offsets[0], offsets[1], slps[2], offsets[0], offsets[1], slps[3], offsets[0], offsets[1], slps[4], offsets[0], offsets[1])) 
    f.close()

    # Run bm
    # path should be the path for BMNS-parent
    os.system('python /Users/orsula1/OneDrive\ -\ Duke\ University/RD/BMNS-parent/BMNS.py -sim BMNS_Simparams.txt output'+str(sim_number))
    os.system('rm BMNS_Simparams.txt')


def get_simulation_cest(slps, offsets, fitpars, alignmag, lf, trelax, inhomo, J):
    ''' run a cest simulation '''
    # Write out simulation file
    f = open('BMNS_Simparams.txt', 'w')
    
    fit_params = [str(ele) for ele in list(fitpars['param'])]

    f.write(cest_simulation%(lf, fitpars['fitval'].iloc[fit_params.index('pB')], fitpars['fitval'].iloc[fit_params.index('dwB')], fitpars['fitval'].iloc[fit_params.index('kexAB')], fitpars['fitval'].iloc[fit_params.index('R1')], fitpars['fitval'].iloc[fit_params.index('R2')], fitpars['fitval'].iloc[fit_params.index('R1')], fitpars['fitval'].iloc[fit_params.index('R2')], fitpars['fitval'].iloc[fit_params.index('R1')], fitpars['fitval'].iloc[fit_params.index('R2')], trelax, alignmag, inhomo, J, slps[0], offsets[0], offsets[1], slps[1], offsets[0], offsets[1], slps[2], offsets[0], offsets[1], slps[3], offsets[0], offsets[1]))   
 
    f.close()    

    os.system('python cest_sim_master_v10.py BMNS_Simparams.txt')
   
    filename = 'pb_' + '%4.3f'%fitpars['fitval'].iloc[fit_params.index('pB')] + '_kex_' + str(int(fitpars['fitval'].iloc[fit_params.index('kexAB')])) + '_T_' + '%3.2f'%trelax + '_r2b_' + '%2.1f'%fitpars['fitval'].iloc[fit_params.index('R2')] + '.csv'

    return filename


def plot_highsl_cest(ax, bf, trendlines, noes_trendlines, axes_lims, xstep, startx, ylims, location):
    ''' plot highsl cest data '''
    color_slps = ['k','b', 'g', 'orange', 'brown', 'r', 'cyan']
    unique_slps  = np.sort(np.unique(bf['slp(hz)']))
    if len(trendlines) != 0:
        unique_slps2 = np.sort(np.unique(trendlines['slp(hz)']))
    #unique_slps3 = np.sort(np.unique(noes_trendlines['slp(hz)']))
    
    counter = 0
    for unique_slp in unique_slps:
        #noes_sim = noes_trendlines.loc[noes_trendlines['slp(hz)'] == unique_slps3[counter]]
        #ax.plot(noes_sim['offset(hz)'], noes_sim['norm_intensity'], color=color_slps[counter], linewidth=2, linestyle="--", zorder=0, label='')

        bf_subset = bf.loc[bf['slp(hz)'] == unique_slp]
        ax.errorbar(bf_subset['offset(hz)'], bf_subset['norm_intensity'], yerr=bf_subset['norm_intensity_error'], fmt='o', color=color_slps[counter], zorder=10*(counter+1), elinewidth=2, markersize=5, label=str(int(math.ceil(unique_slp))))
        #ax.plot(bf_subset['Offset'], bf_subset[' Sim R2eff'], color='k', marker='o', linewidth=0.0) 

        if len(trendlines) != 0:
            trendlines_sim = trendlines.loc[trendlines['slp(hz)'] == unique_slps2[counter]]
            ax.plot(trendlines_sim['offset(hz)'], trendlines_sim['norm_intensity'], color=color_slps[counter], linewidth=2, zorder=10*(counter+1), label='')
 
        counter = counter + 1

        ax.tick_params(axis='x', direction='out', width=4, length=8, top=False)
        ax.tick_params(axis='y', direction='out', width=4, length=8, right=False)
    
        ax.set_xlim(axes_lims)
        ax.set_xticks([int(ele) for ele in np.arange(startx, axes_lims[1]+1, xstep)])
        ax.set_xticklabels([int(float(ele)/1000.) for ele in np.arange(startx, axes_lims[1]+1, xstep)], fontsize=fs)

        ax.set_ylim([ylims[0], ylims[1]])
        ax.set_yticks([ele for ele in np.arange(ylims[2], ylims[1]+0.02, ylims[3])])
        ax.set_yticklabels(['%2.1f'%(ele) for ele in np.arange(ylims[2], ylims[1]+0.02, ylims[3])], fontsize=fs)
    ax.set_ylabel('Norm. Intensity', fontsize=fs)

    counter = 0
    handles, labels = ax.get_legend_handles_labels()
    handles = [h[0] if type(h) is not mpl.lines.Line2D else h for h in handles]
    leg = ax.legend(handles, labels, title='$\omega_{1}/2\pi$' + ' ' + '$(Hz)$', fancybox=False, ncol=4, handlelength=0, frameon=False, columnspacing=0.0, markerscale=0.0, handletextpad=0.5, borderpad=0.0, handleheight=0.0, labelspacing=0.2, loc=location, fontsize=fs)
    for text in leg.get_texts():
        text.set_color(color_slps[counter])
        counter = counter + 1
    for l in leg.get_lines():
        l.set_linestyle('None')
    leg.set_title('$\omega_{1}/2\pi$' + ' ' + '$(Hz)$', prop={'size':fs})


def plot_lowsl_cest(ax, bf, ylims, title, location, sub_xlims, nbins, sub_ylims, sub_ylabels, sub_xaxislab_fmt):
    ''' plot lowsl cest data '''
    color_slps = ['k', 'b', 'g', 'orange', 'brown','r','cyan']
    unique_slps  = np.sort(np.unique(bf['slp(hz)']))
    
    counter = 0
  
    # Plot offset vs. normalized intensity plot
    x = []
    y = []
    for unique_slp in unique_slps:
        xpos_error = []
        ypos_error = []
        xpos = []
        ypos = []
        bf_subset = bf.loc[bf['slp(hz)'] == unique_slp]
        bf_subset_pos = bf_subset.loc[bf_subset['offset(hz)'] > 0]
        bf_subset_neg = bf_subset.loc[bf_subset['offset(hz)']<=0]

        pos_offset_values = list(np.array(bf_subset_pos['offset(hz)'].values))
        neg_offset_values = list(np.array(bf_subset_neg['offset(hz)'].values))
        for dummy in range(len(pos_offset_values)):
            find_offset = pos_offset_values[dummy] * -1.0
            if find_offset in neg_offset_values:
                index = neg_offset_values.index(find_offset) 
                xpos.append(bf_subset_pos['norm_intensity'].iloc[dummy])
                ypos.append(bf_subset_neg['norm_intensity'].iloc[index])
                xpos_error.append(bf_subset_pos['norm_intensity_error'].iloc[dummy])
                ypos_error.append(bf_subset_neg['norm_intensity_error'].iloc[index])
                 
                #ax.errorbar(bf_subset_pos['norm_intensity'].iloc[dummy], bf_subset_neg['norm_intensity'].iloc[index], xerr=bf_subset_pos['norm_intensity_error'].iloc[dummy], yerr=bf_subset_neg['norm_intensity_error'].iloc[index], fmt='o', color=color_slps[counter], markersize=1)
                x.append(bf_subset_pos['norm_intensity'].iloc[dummy])
                y.append(bf_subset_neg['norm_intensity'].iloc[index])
            #else:
            #    print "Offset = ", find_offset, " not present for SLP ", unique_slp
        xpos = np.array(xpos)
        ypos = np.array(ypos)
        xpos_error = np.array(xpos_error)
        ypos_error = np.array(ypos_error)
 
        ax.errorbar(xpos, ypos, yerr=ypos_error, xerr=xpos_error, fmt='o', color=color_slps[counter], markersize=1, label=str(int(math.ceil(unique_slp))))
        #ax.errorbar(bf_subset_neg['offset(hz)'].values*-1., bf_subset_neg['norm_intensity'].values, yerr=bf_subset_neg['norm_intensity_error'].values, fmt='s', color=color_slps[counter])

        counter = counter + 1

        ax.tick_params(axis='x', direction='out', width=2, top=False)
        ax.tick_params(axis='y', direction='out', width=2, right=False)
    
        ax.set_ylim([ylims[0], ylims[1]])
        ax.set_yticks([ele for ele in np.arange(ylims[2], ylims[1]+0.02, ylims[3])])
        ax.set_yticklabels(['%2.1f'%(ele) for ele in np.arange(ylims[2], ylims[1]+0.02, ylims[3])], fontsize=fs)

        ax.set_xlim([ylims[0], ylims[1]])
        ax.set_xticks([ele for ele in np.arange(ylims[2], ylims[1]+0.02, ylims[3])])
        ax.set_xticklabels(['%2.1f'%(ele) for ele in np.arange(ylims[2], ylims[1]+0.02, ylims[3])], fontsize=fs)

        ax.plot([ylims[0], ylims[1]], [ylims[0], ylims[1]], label='', color='k')

    # Compute r2
    x = np.array(x)
    y = np.array(y)
    sstot = np.sum(np.square(x-np.mean(x)))
    ssres = np.sum(np.square(y-x))
    r2 = 1. - (ssres/sstot)
    #ax.text(0.4, 0.0, '$R^{2}=$'+'%4.3f'%r2, fontsize=fs)
    ax.set_title(title, fontsize=fs)

    # Handle inset
    res = x-y
    # Check whether elements are outside boundaries
    if len(res[(res<sub_xlims[0]) | (res>sub_xlims[1])]) > 0:
        print "elements outside limits"
        sys.exit(0)
       
    axins = inset_axes(ax, width="75%", height="75%", bbox_to_anchor=[0.49, 0.0, 0.5, 0.5], bbox_transform=ax.transAxes, borderpad=0.2)
    #axins = inset_axes(ax, width="75%", height="75%", bbox_to_anchor=[0.0, 0.0, 1.0, 1.0], bbox_transform=ax.transAxes)
    #ax.add_patch(plt.Rectangle((0.5,0.0), 0.5, 0.5, ls="--", transform=ax.transAxes))
    axins.hist(res, nbins, range=(sub_xlims[0], sub_xlims[1]), weights=np.ones_like(res)/len(res), histtype='bar', color='r', zorder=0, linewidth=0.1)    
    axins.set_xlim([sub_xlims[0], sub_xlims[1]])

    axins.set_ylim(sub_ylims)
    axins.plot([0.0, 0.0], [0.0, sub_ylims[1]], color='k', linewidth=2, linestyle="--", zorder=10)
    axins.tick_params(axis='x', direction='out', width=2, top=False, pad=0)
    axins.tick_params(axis='y', direction='out', width=2, right=False, pad=0)
    print np.arange(sub_ylabels[0], sub_ylabels[1]+0.01, sub_ylabels[2])
    axins.set_yticks([ele for ele in np.arange(sub_ylabels[0], sub_ylabels[1]+0.01, sub_ylabels[2])])
    axins.set_yticklabels(['%2.1f'%(ele) for ele in np.arange(sub_ylabels[0], sub_ylabels[1]+0.01, sub_ylabels[2])], fontsize=fs)
    axins.set_xticks([ele for ele in np.arange(sub_xlims[2], sub_xlims[1], sub_xlims[3])])
    axins.set_xticklabels([sub_xaxislab_fmt%(ele) for ele in np.arange(sub_xlims[2], sub_xlims[1], sub_xlims[3])], fontsize=fs)
    #axins.set_xlabel('Norm. Intensity(' + '$\Omega$' + '>0)-\nNorm. Intensity(' + '$\Omega$' + '<0)', fontsize=fs)
    #axins.set_xlabel('NI(' + '$\Omega$' + '>0)-NI(' + '$\Omega$' + '<0)', fontsize=fs, labelpad=0, horizontalalignment='center')
    axins.text(0.5, 0.01, 'N.I.(' + '$\Omega$' + '>0)-N.I.(' + '$\Omega$' + '<0)', fontsize=fs, transform=ax.transAxes)
    axins.set_ylabel('Probability', fontsize=fs, labelpad=0)

    # Handle legends
    counter = 0
    handles, labels = ax.get_legend_handles_labels()
    handles = [h[0] if type(h) is not mpl.lines.Line2D else h for h in handles]
    leg = ax.legend(handles, labels, title='$\omega_{1}/2\pi$' + ' ' + '$(Hz)$', fancybox=False, ncol=2, handlelength=0, frameon=False, columnspacing=0.0, markerscale=0.0, handletextpad=0.5, borderpad=0.0, handleheight=0.0, labelspacing=0.2, loc=location, fontsize=fs)
    for text in leg.get_texts():
        text.set_color(color_slps[counter])
        counter = counter + 1
    for l in leg.get_lines():
        l.set_linestyle('None')
    leg.set_title('$\omega_{1}/2\pi$' + ' ' + '$(Hz)$', prop={'size':fs})

# bar plots
def draw_bar(ax, xvals, yvals, bar_width, yerr_vals, xlims, xticks, xticklabels, yticks, yticklabels, fmt_string, ylabel, ylim):
    ''' draw a bar graph with 2 bars '''
    ax.bar(xvals, yvals, width=bar_width, yerr=yerr_vals, align='center', linewidth=2, capsize=15, error_kw={'elinewidth':2, 'capthick':2}, ecolor='k', color='brown')
    ax.tick_params(axis='x', direction='out', width=2, top=False)
    ax.tick_params(axis='y', direction='out', width=2, right=False)
    ax.set_xlim(xlims)
    ax.set_xticks(xticks)
    ax.set_xticklabels(xticklabels, fontsize=fs)
    ax.set_yticks(yticks)
    ax.set_yticklabels([fmt_string%ele for ele in yticklabels], fontsize=fs)
    ax.set_ylabel(ylabel, fontsize=fs)
    ax.set_ylim(ylim)


# plot RD figures, use get_simulation to create simulated fitting curves in output folders. Once output folders are created, comment out the get_simulation line

parent_path = '/Users/orsula1/OrsDocs/OrsDocs_since_Jan2023/2023-RNA-DNA-Hybrid/2023-Manuscript-Figures/2023-For-Data-Deposition/2023-RD-Figures/2023-RD-RawData/'
path_3state_triangle = '3state-triangle-shared/'
path_3state_starlike = '3state-starlike-shared/'
path_2state = '2state-shared/'
path_dTrG_7p4 = 'dTrG_pH7p4/global/'
path_dGrU_7p4 = 'dGrU_pH7p4/global/'
path_dTrG_7p8 = 'dTrG_pH7p8/global/'
path_dGrU_7p8 = 'dGrU_pH7p8/global/'

# Figure 2A, pH 7.4
fig, ax = plt.subplots(2, 2, figsize=(12, 11))

#dTrG, pH 7.4, 2state - GN1
data_all = 'Local/Data_gn1_4pts_1.csv'
fitpars  = 'LocalFits_gn1_4pts.csv'
dTrG_GN1_2_7p4_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dTrG_7p4,path_2state,data_all))
dTrG_GN1_2_7p4_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dTrG_7p4,path_2state,fitpars))
dTrG_GN1_2_7p4_25c_r1p_slps = np.sort(np.unique(dTrG_GN1_2_7p4_25c_r1p['SLP']))
dTrG_GN1_2_7p4_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dTrG_GN1_2_7p4_25c_r1p_slps, dTrG_GN1_2_7p4_25c_r1p_offset_lim, dTrG_GN1_2_7p4_25c_r1p_fitpars, 101)

dTrG_GN1_2_7p4_25c_r1p_trendlines = pd.read_csv('output101/sim-r1p.csv')

plot_r1p(ax[0, 0], dTrG_GN1_2_7p4_25c_r1p, dTrG_GN1_2_7p4_25c_r1p_trendlines, dTrG_GN1_2_7p4_25c_r1p_offset_lim, 6000., 2000., [-2., 34., 6.], '%d')
plot_title = ax[0, 0].set_title('rG18-N1', fontsize=fs)
plot_title.set_position([0.5, 1.02])

#dTrG, pH 7.4, 2state - TN3
data_all = 'Local/Data_un3_4pts_1.csv'
fitpars  = 'LocalFits_un3_4pts.csv'
dTrG_TN3_2_7p4_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dTrG_7p4,path_2state,data_all))
dTrG_TN3_2_7p4_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dTrG_7p4,path_2state,fitpars))
dTrG_TN3_2_7p4_25c_r1p_slps = np.sort(np.unique(dTrG_TN3_2_7p4_25c_r1p['SLP']))
dTrG_TN3_2_7p4_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dTrG_TN3_2_7p4_25c_r1p_slps, dTrG_TN3_2_7p4_25c_r1p_offset_lim, dTrG_TN3_2_7p4_25c_r1p_fitpars, 102)

dTrG_TN3_2_7p4_25c_r1p_trendlines = pd.read_csv('output102/sim-r1p.csv')

plot_r1p(ax[0, 1], dTrG_TN3_2_7p4_25c_r1p, dTrG_TN3_2_7p4_25c_r1p_trendlines, dTrG_TN3_2_7p4_25c_r1p_offset_lim, 6000., 2000., [-2., 28., 6.], '%d')
plot_title = ax[0, 1].set_title('dT7-N3', fontsize=fs)
plot_title.set_position([0.5, 1.02])

ax[0, 0].set_xticklabels([])
ax[0, 1].set_xticklabels([])

#dGrU, pH 7.4, 3state - GN1
data_all = 'Local/Data_gn1_4pts_1.csv'
fitpars  = 'LocalFits_gn1_4pts.csv'
dGrU_GN1_3_7p4_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dGrU_7p4,path_3state_triangle,data_all))
dGrU_GN1_3_7p4_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dGrU_7p4,path_3state_triangle,fitpars))
dGrU_GN1_3_7p4_25c_r1p_slps = np.sort(np.unique(dGrU_GN1_3_7p4_25c_r1p['SLP']))
dGrU_GN1_3_7p4_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dGrU_GN1_3_7p4_25c_r1p_slps, dGrU_GN1_3_7p4_25c_r1p_offset_lim, dGrU_GN1_3_7p4_25c_r1p_fitpars, 103)

dGrU_GN1_3_7p4_25c_r1p_trendlines = pd.read_csv('output103/sim-r1p.csv')

plot_r1p(ax[1, 0], dGrU_GN1_3_7p4_25c_r1p, dGrU_GN1_3_7p4_25c_r1p_trendlines, dGrU_GN1_3_7p4_25c_r1p_offset_lim, 6000., 2000., [-2., 34., 6.], '%d')
plot_title = ax[1, 0].set_title('dG7-N1', fontsize=fs)
plot_title.set_position([0.5, 1.02])

#dGrU, pH 7.4, 3state - UN3
data_all = 'Local/Data_un3_3pts_1.csv'
fitpars  = 'LocalFits_un3_3pts.csv'
dGrU_UN3_3_7p4_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dGrU_7p4,path_3state_triangle,data_all))
dGrU_UN3_3_7p4_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dGrU_7p4,path_3state_triangle,fitpars))
dGrU_UN3_3_7p4_25c_r1p_slps = np.sort(np.unique(dGrU_UN3_3_7p4_25c_r1p['SLP']))
dGrU_UN3_3_7p4_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dGrU_UN3_3_7p4_25c_r1p_slps, dGrU_UN3_3_7p4_25c_r1p_offset_lim, dGrU_UN3_3_7p4_25c_r1p_fitpars, 104)

dGrU_UN3_3_7p4_25c_r1p_trendlines = pd.read_csv('output104/sim-r1p.csv')

plot_r1p(ax[1, 1], dGrU_UN3_3_7p4_25c_r1p, dGrU_UN3_3_7p4_25c_r1p_trendlines, dGrU_UN3_3_7p4_25c_r1p_offset_lim, 6000., 2000., [-2., 198., 40.], '%d')
plot_title = ax[1, 1].set_title('rU18-N3', fontsize=fs)
plot_title.set_position([0.5, 1.02])

ax[0, 0].set_ylabel('$R_{2}$' + ' + ' + '$R_{ex}$' + ' (s' + '$^{-1}$' + ')', fontsize=fs)
ax[1, 0].set_ylabel('$R_{2}$' + ' + ' + '$R_{ex}$' + ' (s' + '$^{-1}$' + ')', fontsize=fs)
ax[1, 0].set_xlabel('$\Omega_{OBS}$' + "/" + '2' + '$\pi$' + ' ' + "(kHz)", fontsize=fs)
ax[1, 1].set_xlabel('$\Omega_{OBS}$' + "/" + '2' + '$\pi$' + ' ' + "(kHz)", fontsize=fs)

fig.suptitle('Hybrids pH 7.4', fontsize=fs)
plt.savefig('hybrid_fits_pH7p4_main.pdf')

# Figure 2C, pH 7.8
fig, ax = plt.subplots(2, 2, figsize=(12, 11))

#dTrG, pH 7.8, 3state - GN1
data_all = 'Local/Data_GN1_1.csv'
fitpars  = 'LocalFits_GN1.csv'
dTrG_GN1_3_7p8_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dTrG_7p8,path_3state_triangle,data_all))
dTrG_GN1_3_7p8_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dTrG_7p8,path_3state_triangle,fitpars))
dTrG_GN1_3_7p8_25c_r1p_slps = np.sort(np.unique(dTrG_GN1_3_7p8_25c_r1p['SLP']))
dTrG_GN1_3_7p8_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dTrG_GN1_3_7p8_25c_r1p_slps, dTrG_GN1_3_7p8_25c_r1p_offset_lim, dTrG_GN1_3_7p8_25c_r1p_fitpars, 201)

dTrG_GN1_3_7p8_25c_r1p_trendlines = pd.read_csv('output201/sim-r1p.csv')

plot_r1p(ax[0, 0], dTrG_GN1_3_7p8_25c_r1p, dTrG_GN1_3_7p8_25c_r1p_trendlines, dTrG_GN1_3_7p8_25c_r1p_offset_lim, 6000., 2000., [-2., 34., 6.], '%d')
plot_title = ax[0, 0].set_title('rG18-N1', fontsize=fs)
plot_title.set_position([0.5, 1.02])

#dTrG, pH 7.8, 3state - TN3
data_all = 'Local/Data_TN3_1.csv'
fitpars  = 'LocalFits_TN3.csv'
dTrG_TN3_3_7p8_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dTrG_7p8,path_3state_triangle,data_all))
dTrG_TN3_3_7p8_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dTrG_7p8,path_3state_triangle,fitpars))
dTrG_TN3_3_7p8_25c_r1p_slps = np.sort(np.unique(dTrG_TN3_3_7p8_25c_r1p['SLP']))
dTrG_TN3_3_7p8_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dTrG_TN3_3_7p8_25c_r1p_slps, dTrG_TN3_3_7p8_25c_r1p_offset_lim, dTrG_TN3_3_7p8_25c_r1p_fitpars, 202)

dTrG_TN3_3_7p8_25c_r1p_trendlines = pd.read_csv('output202/sim-r1p.csv')

plot_r1p(ax[0, 1], dTrG_TN3_3_7p8_25c_r1p, dTrG_TN3_3_7p8_25c_r1p_trendlines, dTrG_TN3_3_7p8_25c_r1p_offset_lim, 6000., 2000., [-2., 28., 6.], '%d')
plot_title = ax[0, 1].set_title('dT7-N3', fontsize=fs)
plot_title.set_position([0.5, 1.02])

ax[0, 0].set_xticklabels([])
ax[0, 1].set_xticklabels([])

#dGrU, pH 7.8, 3state - GN1
data_all = 'Local/Data_N1_1.csv'
fitpars  = 'LocalFits_N1.csv'
dGrU_GN1_3_7p8_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dGrU_7p8,path_3state_triangle,data_all))
dGrU_GN1_3_7p8_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dGrU_7p8,path_3state_triangle,fitpars))
dGrU_GN1_3_7p8_25c_r1p_slps = np.sort(np.unique(dGrU_GN1_3_7p8_25c_r1p['SLP']))
dGrU_GN1_3_7p8_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dGrU_GN1_3_7p8_25c_r1p_slps, dGrU_GN1_3_7p8_25c_r1p_offset_lim, dGrU_GN1_3_7p8_25c_r1p_fitpars, 203)

dGrU_GN1_3_7p8_25c_r1p_trendlines = pd.read_csv('output203/sim-r1p.csv')

plot_r1p(ax[1, 0], dGrU_GN1_3_7p8_25c_r1p, dGrU_GN1_3_7p8_25c_r1p_trendlines, dGrU_GN1_3_7p8_25c_r1p_offset_lim, 6000., 2000., [-2., 34., 6.], '%d')
plot_title = ax[1, 0].set_title('dG7-N1', fontsize=fs)
plot_title.set_position([0.5, 1.02])

#dGrU, pH 7.8, 3state - UN3
data_all = 'Local/Data_N3_1.csv'
fitpars  = 'LocalFits_N3.csv'
dGrU_UN3_3_7p8_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dGrU_7p8,path_3state_triangle,data_all))
dGrU_UN3_3_7p8_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dGrU_7p8,path_3state_triangle,fitpars))
dGrU_UN3_3_7p8_25c_r1p_slps = np.sort(np.unique(dGrU_UN3_3_7p8_25c_r1p['SLP']))
dGrU_UN3_3_7p8_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dGrU_UN3_3_7p8_25c_r1p_slps, dGrU_UN3_3_7p8_25c_r1p_offset_lim, dGrU_UN3_3_7p8_25c_r1p_fitpars, 204)

dGrU_UN3_3_7p8_25c_r1p_trendlines = pd.read_csv('output204/sim-r1p.csv')

plot_r1p(ax[1, 1], dGrU_UN3_3_7p8_25c_r1p, dGrU_UN3_3_7p8_25c_r1p_trendlines, dGrU_UN3_3_7p8_25c_r1p_offset_lim, 6000., 2000., [-2., 198., 40.], '%d')
plot_title = ax[1, 1].set_title('rU18-N3', fontsize=fs)
plot_title.set_position([0.5, 1.02])

ax[0, 0].set_ylabel('$R_{2}$' + ' + ' + '$R_{ex}$' + ' (s' + '$^{-1}$' + ')', fontsize=fs)
ax[1, 0].set_ylabel('$R_{2}$' + ' + ' + '$R_{ex}$' + ' (s' + '$^{-1}$' + ')', fontsize=fs)
ax[1, 0].set_xlabel('$\Omega_{OBS}$' + "/" + '2' + '$\pi$' + ' ' + "(kHz)", fontsize=fs)
ax[1, 1].set_xlabel('$\Omega_{OBS}$' + "/" + '2' + '$\pi$' + ' ' + "(kHz)", fontsize=fs)

fig.suptitle('Hybrids pH 7.8', fontsize=fs)
plt.savefig('hybrid_fits_pH7p8_main.pdf')

# Figure S2A, dTrG pH 7.4
fig, ax = plt.subplots(2, 2, figsize=(12, 11))

#dTrG, pH 7.4, 2state - GN1
data_all = 'Local/Data_gn1_4pts_1.csv'
fitpars  = 'LocalFits_gn1_4pts.csv'
dTrG_GN1_2_7p4_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dTrG_7p4,path_2state,data_all))
dTrG_GN1_2_7p4_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dTrG_7p4,path_2state,fitpars))
dTrG_GN1_2_7p4_25c_r1p_slps = np.sort(np.unique(dTrG_GN1_2_7p4_25c_r1p['SLP']))
dTrG_GN1_2_7p4_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dTrG_GN1_2_7p4_25c_r1p_slps, dTrG_GN1_2_7p4_25c_r1p_offset_lim, dTrG_GN1_2_7p4_25c_r1p_fitpars, 101)

dTrG_GN1_2_7p4_25c_r1p_trendlines = pd.read_csv('output101/sim-r1p.csv')

plot_r1p(ax[0, 0], dTrG_GN1_2_7p4_25c_r1p, dTrG_GN1_2_7p4_25c_r1p_trendlines, dTrG_GN1_2_7p4_25c_r1p_offset_lim, 6000., 2000., [-2., 34., 6.], '%d')
plot_title = ax[0, 0].set_title('rG18-N1', fontsize=fs)
plot_title.set_position([0.5, 1.02])

#dTrG, pH 7.4, 2state - TN3
data_all = 'Local/Data_un3_4pts_1.csv'
fitpars  = 'LocalFits_un3_4pts.csv'
dTrG_TN3_2_7p4_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dTrG_7p4,path_2state,data_all))
dTrG_TN3_2_7p4_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dTrG_7p4,path_2state,fitpars))
dTrG_TN3_2_7p4_25c_r1p_slps = np.sort(np.unique(dTrG_TN3_2_7p4_25c_r1p['SLP']))
dTrG_TN3_2_7p4_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dTrG_TN3_2_7p4_25c_r1p_slps, dTrG_TN3_2_7p4_25c_r1p_offset_lim, dTrG_TN3_2_7p4_25c_r1p_fitpars, 102)

dTrG_TN3_2_7p4_25c_r1p_trendlines = pd.read_csv('output102/sim-r1p.csv')

plot_r1p(ax[0, 1], dTrG_TN3_2_7p4_25c_r1p, dTrG_TN3_2_7p4_25c_r1p_trendlines, dTrG_TN3_2_7p4_25c_r1p_offset_lim, 6000., 2000., [-2., 28., 6.], '%d')
plot_title = ax[0, 1].set_title('dT7-N3', fontsize=fs)
plot_title.set_position([0.5, 1.02])

ax[0, 0].set_xticklabels([])
ax[0, 1].set_xticklabels([])

#dTrG, pH 7.4, 3state - GN1
data_all = 'Local/Data_gn1_4pts_1.csv'
fitpars  = 'LocalFits_gn1_4pts.csv'
dTrG_GN1_3_7p4_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dTrG_7p4,path_3state_starlike,data_all))
dTrG_GN1_3_7p4_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dTrG_7p4,path_3state_starlike,fitpars))
dTrG_GN1_3_7p4_25c_r1p_slps = np.sort(np.unique(dTrG_GN1_3_7p4_25c_r1p['SLP']))
dTrG_GN1_3_7p4_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dTrG_GN1_3_7p4_25c_r1p_slps, dTrG_GN1_3_7p4_25c_r1p_offset_lim, dTrG_GN1_3_7p4_25c_r1p_fitpars, 301)

dTrG_GN1_3_7p4_25c_r1p_trendlines = pd.read_csv('output301/sim-r1p.csv')

plot_r1p(ax[1, 0], dTrG_GN1_3_7p4_25c_r1p, dTrG_GN1_3_7p4_25c_r1p_trendlines, dTrG_GN1_3_7p4_25c_r1p_offset_lim, 6000., 2000., [-2., 34., 6.], '%d')
#plot_title = ax[0, 0].set_title('rG18-N1', fontsize=fs)
#plot_title.set_position([0.5, 1.02])

#dTrG, pH 7.4, 3state - TN3
data_all = 'Local/Data_un3_4pts_1.csv'
fitpars  = 'LocalFits_un3_4pts.csv'
dTrG_TN3_3_7p4_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dTrG_7p4,path_3state_starlike,data_all))
dTrG_TN3_3_7p4_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dTrG_7p4,path_3state_starlike,fitpars))
dTrG_TN3_3_7p4_25c_r1p_slps = np.sort(np.unique(dTrG_TN3_3_7p4_25c_r1p['SLP']))
dTrG_TN3_3_7p4_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dTrG_TN3_3_7p4_25c_r1p_slps, dTrG_TN3_3_7p4_25c_r1p_offset_lim, dTrG_TN3_3_7p4_25c_r1p_fitpars, 302)

dTrG_TN3_3_7p4_25c_r1p_trendlines = pd.read_csv('output302/sim-r1p.csv')

plot_r1p(ax[1, 1], dTrG_TN3_3_7p4_25c_r1p, dTrG_TN3_3_7p4_25c_r1p_trendlines, dTrG_TN3_3_7p4_25c_r1p_offset_lim, 6000., 2000., [-2., 28., 6.], '%d')
#plot_title = ax[0, 1].set_title('dT7-N3', fontsize=fs)
#plot_title.set_position([0.5, 1.02])

ax[0, 0].set_ylabel('2-state\n' + '$R_{2}$' + ' + ' + '$R_{ex}$' + ' (s' + '$^{-1}$' + ')', fontsize=fs)
ax[1, 0].set_ylabel('3-state star-like\n' + '$R_{2}$' + ' + ' + '$R_{ex}$' + ' (s' + '$^{-1}$' + ')', fontsize=fs)
ax[1, 0].set_xlabel('$\Omega_{OBS}$' + "/" + '2' + '$\pi$' + ' ' + "(kHz)", fontsize=fs)
ax[1, 1].set_xlabel('$\Omega_{OBS}$' + "/" + '2' + '$\pi$' + ' ' + "(kHz)", fontsize=fs)

fig.suptitle('dTrG pH 7.4', fontsize=fs)
plt.savefig('dTrG_fits_pH7p4_SI.pdf')

# Figure S2A, dGrU pH 7.4
fig, ax = plt.subplots(2, 2, figsize=(12, 11))

#dGrU, pH 7.4, 2state - GN1
data_all = 'Local/Data_gn1_4pts_1.csv'
fitpars  = 'LocalFits_gn1_4pts.csv'
dGrU_GN1_2_7p4_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dGrU_7p4,path_2state,data_all))
dGrU_GN1_2_7p4_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dGrU_7p4,path_2state,fitpars))
dGrU_GN1_2_7p4_25c_r1p_slps = np.sort(np.unique(dGrU_GN1_2_7p4_25c_r1p['SLP']))
dGrU_GN1_2_7p4_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dGrU_GN1_2_7p4_25c_r1p_slps, dGrU_GN1_2_7p4_25c_r1p_offset_lim, dGrU_GN1_2_7p4_25c_r1p_fitpars, 501)

dGrU_GN1_2_7p4_25c_r1p_trendlines = pd.read_csv('output501/sim-r1p.csv')

plot_r1p(ax[0, 0], dGrU_GN1_2_7p4_25c_r1p, dGrU_GN1_2_7p4_25c_r1p_trendlines, dGrU_GN1_2_7p4_25c_r1p_offset_lim, 6000., 2000., [-2., 34., 6.], '%d')
plot_title = ax[0, 0].set_title('dG7-N1', fontsize=fs)
plot_title.set_position([0.5, 1.02])

#dGrU, pH 7.4, 2state - UN3
data_all = 'Local/Data_un3_3pts_1.csv'
fitpars  = 'LocalFits_un3_3pts.csv'
dGrU_UN3_2_7p4_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dGrU_7p4,path_2state,data_all))
dGrU_UN3_2_7p4_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dGrU_7p4,path_2state,fitpars))
dGrU_UN3_2_7p4_25c_r1p_slps = np.sort(np.unique(dGrU_UN3_2_7p4_25c_r1p['SLP']))
dGrU_UN3_2_7p4_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dGrU_UN3_2_7p4_25c_r1p_slps, dGrU_UN3_2_7p4_25c_r1p_offset_lim, dGrU_UN3_2_7p4_25c_r1p_fitpars, 502)

dGrU_UN3_2_7p4_25c_r1p_trendlines = pd.read_csv('output502/sim-r1p.csv')

plot_r1p(ax[0, 1], dGrU_UN3_2_7p4_25c_r1p, dGrU_UN3_2_7p4_25c_r1p_trendlines, dGrU_UN3_2_7p4_25c_r1p_offset_lim, 6000., 2000., [-2., 198., 40.], '%d')
plot_title = ax[0, 1].set_title('rU18-N3', fontsize=fs)
plot_title.set_position([0.5, 1.02])

ax[0, 0].set_xticklabels([])
ax[0, 1].set_xticklabels([])

#dGrU, pH 7.4, 3state - GN1
data_all = 'Local/Data_gn1_4pts_1.csv'
fitpars  = 'LocalFits_gn1_4pts.csv'
dGrU_GN1_3_7p4_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dGrU_7p4,path_3state_triangle,data_all))
dGrU_GN1_3_7p4_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dGrU_7p4,path_3state_triangle,fitpars))
dGrU_GN1_3_7p4_25c_r1p_slps = np.sort(np.unique(dGrU_GN1_3_7p4_25c_r1p['SLP']))
dGrU_GN1_3_7p4_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dGrU_GN1_3_7p4_25c_r1p_slps, dGrU_GN1_3_7p4_25c_r1p_offset_lim, dGrU_GN1_3_7p4_25c_r1p_fitpars, 103)

dGrU_GN1_3_7p4_25c_r1p_trendlines = pd.read_csv('output103/sim-r1p.csv')

plot_r1p(ax[1, 0], dGrU_GN1_3_7p4_25c_r1p, dGrU_GN1_3_7p4_25c_r1p_trendlines, dGrU_GN1_3_7p4_25c_r1p_offset_lim, 6000., 2000., [-2., 34., 6.], '%d')
#plot_title = ax[1, 0].set_title('dG7-N1', fontsize=fs)
#plot_title.set_position([0.5, 1.02])

#dGrU, pH 7.4, 3state - UN3
data_all = 'Local/Data_un3_3pts_1.csv'
fitpars  = 'LocalFits_un3_3pts.csv'
dGrU_UN3_3_7p4_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dGrU_7p4,path_3state_triangle,data_all))
dGrU_UN3_3_7p4_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dGrU_7p4,path_3state_triangle,fitpars))
dGrU_UN3_3_7p4_25c_r1p_slps = np.sort(np.unique(dGrU_UN3_3_7p4_25c_r1p['SLP']))
dGrU_UN3_3_7p4_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dGrU_UN3_3_7p4_25c_r1p_slps, dGrU_UN3_3_7p4_25c_r1p_offset_lim, dGrU_UN3_3_7p4_25c_r1p_fitpars, 104)

dGrU_UN3_3_7p4_25c_r1p_trendlines = pd.read_csv('output104/sim-r1p.csv')

plot_r1p(ax[1, 1], dGrU_UN3_3_7p4_25c_r1p, dGrU_UN3_3_7p4_25c_r1p_trendlines, dGrU_UN3_3_7p4_25c_r1p_offset_lim, 6000., 2000., [-2., 198., 40.], '%d')
#plot_title = ax[1, 1].set_title('rU18-N3', fontsize=fs)
#plot_title.set_position([0.5, 1.02])

ax[0, 0].set_ylabel('2-state\n' + '$R_{2}$' + ' + ' + '$R_{ex}$' + ' (s' + '$^{-1}$' + ')', fontsize=fs)
ax[1, 0].set_ylabel('3-state triangular\n' + '$R_{2}$' + ' + ' + '$R_{ex}$' + ' (s' + '$^{-1}$' + ')', fontsize=fs)
ax[1, 0].set_xlabel('$\Omega_{OBS}$' + "/" + '2' + '$\pi$' + ' ' + "(kHz)", fontsize=fs)
ax[1, 1].set_xlabel('$\Omega_{OBS}$' + "/" + '2' + '$\pi$' + ' ' + "(kHz)", fontsize=fs)

fig.suptitle('dGrU pH 7.4', fontsize=fs)
plt.savefig('dGrU_fits_pH7p4_SI.pdf')

# Figure S2B, dTrG pH 7.8
fig, ax = plt.subplots(2, 2, figsize=(12, 11))

#dTrG, pH 7.8, 2state - GN1
data_all = 'Local/Data_GN1_1.csv'
fitpars  = 'LocalFits_GN1.csv'
dTrG_GN1_2_7p8_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dTrG_7p8,path_2state,data_all))
dTrG_GN1_2_7p8_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dTrG_7p8,path_2state,fitpars))
dTrG_GN1_2_7p8_25c_r1p_slps = np.sort(np.unique(dTrG_GN1_2_7p8_25c_r1p['SLP']))
dTrG_GN1_2_7p8_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dTrG_GN1_2_7p8_25c_r1p_slps, dTrG_GN1_2_7p8_25c_r1p_offset_lim, dTrG_GN1_2_7p8_25c_r1p_fitpars, 401)

dTrG_GN1_2_7p8_25c_r1p_trendlines = pd.read_csv('output401/sim-r1p.csv')

plot_r1p(ax[0, 0], dTrG_GN1_2_7p8_25c_r1p, dTrG_GN1_2_7p8_25c_r1p_trendlines, dTrG_GN1_2_7p8_25c_r1p_offset_lim, 6000., 2000., [-2., 34., 6.], '%d')
plot_title = ax[0, 0].set_title('rG18-N1', fontsize=fs)
plot_title.set_position([0.5, 1.02])

#dTrG, pH 7.8, 2state - TN3
data_all = 'Local/Data_TN3_1.csv'
fitpars  = 'LocalFits_TN3.csv'
dTrG_TN3_2_7p8_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dTrG_7p8,path_2state,data_all))
dTrG_TN3_2_7p8_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dTrG_7p8,path_2state,fitpars))
dTrG_TN3_2_7p8_25c_r1p_slps = np.sort(np.unique(dTrG_TN3_2_7p8_25c_r1p['SLP']))
dTrG_TN3_2_7p8_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dTrG_TN3_2_7p8_25c_r1p_slps, dTrG_TN3_2_7p8_25c_r1p_offset_lim, dTrG_TN3_2_7p8_25c_r1p_fitpars, 402)

dTrG_TN3_2_7p8_25c_r1p_trendlines = pd.read_csv('output402/sim-r1p.csv')

plot_r1p(ax[0, 1], dTrG_TN3_2_7p8_25c_r1p, dTrG_TN3_2_7p8_25c_r1p_trendlines, dTrG_TN3_2_7p8_25c_r1p_offset_lim, 6000., 2000., [-2., 28., 6.], '%d')
plot_title = ax[0, 1].set_title('dT7-N3', fontsize=fs)
plot_title.set_position([0.5, 1.02])

ax[0, 0].set_xticklabels([])
ax[0, 1].set_xticklabels([])

#dTrG, pH 7.8, 3state - GN1
data_all = 'Local/Data_GN1_1.csv'
fitpars  = 'LocalFits_GN1.csv'
dTrG_GN1_3_7p8_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dTrG_7p8,path_3state_triangle,data_all))
dTrG_GN1_3_7p8_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dTrG_7p8,path_3state_triangle,fitpars))
dTrG_GN1_3_7p8_25c_r1p_slps = np.sort(np.unique(dTrG_GN1_3_7p8_25c_r1p['SLP']))
dTrG_GN1_3_7p8_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dTrG_GN1_3_7p8_25c_r1p_slps, dTrG_GN1_3_7p8_25c_r1p_offset_lim, dTrG_GN1_3_7p8_25c_r1p_fitpars, 201)

dTrG_GN1_3_7p8_25c_r1p_trendlines = pd.read_csv('output201/sim-r1p.csv')

plot_r1p(ax[1, 0], dTrG_GN1_3_7p8_25c_r1p, dTrG_GN1_3_7p8_25c_r1p_trendlines, dTrG_GN1_3_7p8_25c_r1p_offset_lim, 6000., 2000., [-2., 34., 6.], '%d')
#plot_title = ax[0, 0].set_title('rG18-N1', fontsize=fs)
#plot_title.set_position([0.5, 1.02])

#dTrG, pH 7.8, 3state - TN3
data_all = 'Local/Data_TN3_1.csv'
fitpars  = 'LocalFits_TN3.csv'
dTrG_TN3_3_7p8_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dTrG_7p8,path_3state_triangle,data_all))
dTrG_TN3_3_7p8_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dTrG_7p8,path_3state_triangle,fitpars))
dTrG_TN3_3_7p8_25c_r1p_slps = np.sort(np.unique(dTrG_TN3_3_7p8_25c_r1p['SLP']))
dTrG_TN3_3_7p8_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dTrG_TN3_3_7p8_25c_r1p_slps, dTrG_TN3_3_7p8_25c_r1p_offset_lim, dTrG_TN3_3_7p8_25c_r1p_fitpars, 202)

dTrG_TN3_3_7p8_25c_r1p_trendlines = pd.read_csv('output202/sim-r1p.csv')

plot_r1p(ax[1, 1], dTrG_TN3_3_7p8_25c_r1p, dTrG_TN3_3_7p8_25c_r1p_trendlines, dTrG_TN3_3_7p8_25c_r1p_offset_lim, 6000., 2000., [-2., 28., 6.], '%d')
#plot_title = ax[0, 1].set_title('dT7-N3', fontsize=fs)
#plot_title.set_position([0.5, 1.02])

ax[0, 0].set_ylabel('2-state\n' + '$R_{2}$' + ' + ' + '$R_{ex}$' + ' (s' + '$^{-1}$' + ')', fontsize=fs)
ax[1, 0].set_ylabel('3-state triangular\n' + '$R_{2}$' + ' + ' + '$R_{ex}$' + ' (s' + '$^{-1}$' + ')', fontsize=fs)
ax[1, 0].set_xlabel('$\Omega_{OBS}$' + "/" + '2' + '$\pi$' + ' ' + "(kHz)", fontsize=fs)
ax[1, 1].set_xlabel('$\Omega_{OBS}$' + "/" + '2' + '$\pi$' + ' ' + "(kHz)", fontsize=fs)

fig.suptitle('dTrG pH 7.8', fontsize=fs)
plt.savefig('dTrG_fits_pH7p8_SI.pdf')

# Figure S2B, dGrU pH 7.8
fig, ax = plt.subplots(2, 2, figsize=(12, 11))

#dGrU, pH 7.8, 2state - GN1
data_all = 'Local/Data_N1_1.csv'
fitpars  = 'LocalFits_N1.csv'
dGrU_GN1_2_7p8_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dGrU_7p8,path_2state,data_all))
dGrU_GN1_2_7p8_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dGrU_7p8,path_2state,fitpars))
dGrU_GN1_2_7p8_25c_r1p_slps = np.sort(np.unique(dGrU_GN1_2_7p8_25c_r1p['SLP']))
dGrU_GN1_2_7p8_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dGrU_GN1_2_7p8_25c_r1p_slps, dGrU_GN1_2_7p8_25c_r1p_offset_lim, dGrU_GN1_2_7p8_25c_r1p_fitpars, 601)

dGrU_GN1_2_7p8_25c_r1p_trendlines = pd.read_csv('output601/sim-r1p.csv')

plot_r1p(ax[0, 0], dGrU_GN1_2_7p8_25c_r1p, dGrU_GN1_2_7p8_25c_r1p_trendlines, dGrU_GN1_2_7p8_25c_r1p_offset_lim, 6000., 2000., [-2., 34., 6.], '%d')
plot_title = ax[0, 0].set_title('dG7-N1', fontsize=fs)
plot_title.set_position([0.5, 1.02])

#dGrU, pH 7.8, 2state - UN3
data_all = 'Local/Data_N3_1.csv'
fitpars  = 'LocalFits_N3.csv'
dGrU_UN3_2_7p8_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dGrU_7p8,path_2state,data_all))
dGrU_UN3_2_7p8_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dGrU_7p8,path_2state,fitpars))
dGrU_UN3_2_7p8_25c_r1p_slps = np.sort(np.unique(dGrU_UN3_2_7p8_25c_r1p['SLP']))
dGrU_UN3_2_7p8_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dGrU_UN3_2_7p8_25c_r1p_slps, dGrU_UN3_2_7p8_25c_r1p_offset_lim, dGrU_UN3_2_7p8_25c_r1p_fitpars, 602)

dGrU_UN3_2_7p8_25c_r1p_trendlines = pd.read_csv('output602/sim-r1p.csv')

plot_r1p(ax[0, 1], dGrU_UN3_2_7p8_25c_r1p, dGrU_UN3_2_7p8_25c_r1p_trendlines, dGrU_UN3_2_7p8_25c_r1p_offset_lim, 6000., 2000., [-2., 198., 40.], '%d')
plot_title = ax[0, 1].set_title('rU18-N3', fontsize=fs)
plot_title.set_position([0.5, 1.02])

ax[0, 0].set_xticklabels([])
ax[0, 1].set_xticklabels([])

#dGrU, pH 7.8, 3state - GN1
data_all = 'Local/Data_N1_1.csv'
fitpars  = 'LocalFits_N1.csv'
dGrU_GN1_3_7p8_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dGrU_7p8,path_3state_triangle,data_all))
dGrU_GN1_3_7p8_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dGrU_7p8,path_3state_triangle,fitpars))
dGrU_GN1_3_7p8_25c_r1p_slps = np.sort(np.unique(dGrU_GN1_3_7p8_25c_r1p['SLP']))
dGrU_GN1_3_7p8_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dGrU_GN1_3_7p8_25c_r1p_slps, dGrU_GN1_3_7p8_25c_r1p_offset_lim, dGrU_GN1_3_7p8_25c_r1p_fitpars, 203)

dGrU_GN1_3_7p8_25c_r1p_trendlines = pd.read_csv('output203/sim-r1p.csv')

plot_r1p(ax[1, 0], dGrU_GN1_3_7p8_25c_r1p, dGrU_GN1_3_7p8_25c_r1p_trendlines, dGrU_GN1_3_7p8_25c_r1p_offset_lim, 6000., 2000., [-2., 34., 6.], '%d')
#plot_title = ax[1, 0].set_title('dG7-N1', fontsize=fs)
#plot_title.set_position([0.5, 1.02])

#dGrU, pH 7.8, 3state - UN3
data_all = 'Local/Data_N3_1.csv'
fitpars  = 'LocalFits_N3.csv'
dGrU_UN3_3_7p8_25c_r1p = pd.read_csv(os.path.join(parent_path,path_dGrU_7p8,path_3state_triangle,data_all))
dGrU_UN3_3_7p8_25c_r1p_fitpars = pd.read_csv(os.path.join(parent_path,path_dGrU_7p8,path_3state_triangle,fitpars))
dGrU_UN3_3_7p8_25c_r1p_slps = np.sort(np.unique(dGrU_UN3_3_7p8_25c_r1p['SLP']))
dGrU_UN3_3_7p8_25c_r1p_offset_lim = [-6200., 6200.]
#get_simulation_r1p(dGrU_UN3_3_7p8_25c_r1p_slps, dGrU_UN3_3_7p8_25c_r1p_offset_lim, dGrU_UN3_3_7p8_25c_r1p_fitpars, 204)

dGrU_UN3_3_7p8_25c_r1p_trendlines = pd.read_csv('output204/sim-r1p.csv')

plot_r1p(ax[1, 1], dGrU_UN3_3_7p8_25c_r1p, dGrU_UN3_3_7p8_25c_r1p_trendlines, dGrU_UN3_3_7p8_25c_r1p_offset_lim, 6000., 2000., [-2., 198., 40.], '%d')
#plot_title = ax[1, 1].set_title('rU18-N3', fontsize=fs)
#plot_title.set_position([0.5, 1.02])

ax[0, 0].set_ylabel('2-state\n' + '$R_{2}$' + ' + ' + '$R_{ex}$' + ' (s' + '$^{-1}$' + ')', fontsize=fs)
ax[1, 0].set_ylabel('3-state triangular\n' + '$R_{2}$' + ' + ' + '$R_{ex}$' + ' (s' + '$^{-1}$' + ')', fontsize=fs)
ax[1, 0].set_xlabel('$\Omega_{OBS}$' + "/" + '2' + '$\pi$' + ' ' + "(kHz)", fontsize=fs)
ax[1, 1].set_xlabel('$\Omega_{OBS}$' + "/" + '2' + '$\pi$' + ' ' + "(kHz)", fontsize=fs)

fig.suptitle('dGrU pH 7.8', fontsize=fs)
plt.savefig('dGrU_fits_pH7p8_SI.pdf')
